1. Introduction
	- Introduction to the Course.


2. Project Creation
	- Setup inheritance: AuraCharacterBase is base class, AuraCharacter and AuraEnemy are inherited.
	- 2 different type of enemy (with different animations): Goblin slingshots and Goblin Spearmen.
	- Animations take Velocity from CharacterMovement component and sets it to the Animation (in blueprint).
	- Enhanced Input (IMC file) used in AuraPlayerController. It is stored in IMC file (Input Mapping Context). D keybind is negated A, same for Y axis (Swizzle) etc.
	- Move function is bound to Enhanced Input Component at startup time (SetupInputComponent). Binding to MoveAction (of type UInputAction), then used in the editor with the same name.
	- EnemyInterface abstract class is given to all enemies to inherit from. From the Player Controller, at each tick, we call CursorTrace(), checking the HitResult under the cursor trace. If the actor hit is inheriting the interface (checked with a cast), then we highlight the actor (or unhighlight) with a LastActor/ThisActor logic.


3. Intro to the Gameplay Ability System
	- Enemies have the Ability System Component and AttributeSet directly on the character class, but for the player it is kept on the PlayerState (so it is not lost when the player dies).
	- Each client has its own game state/copy, same for the server, but server's copy is the authorative one. Replication of attribute changes happens only from server to client. If client want to replicate to server, he must use RPCs.
	- Replication Mode on player will be of type Mixed (GEs will be replicated to owning client only), while on enemies will be of type Minimal (GEs won't be replicated).
	- ASCs have Owner Actor and Avatar Actor. So for enemies, Owner and Avatar are the same Enemy Character. For players, the Owner Actor is the Player State, while the Avatar Actor will be the character.
	- InitAbilityActorInfo must be done after possession: for players ASC lives on PlayerState, so make sure that PlayerState is valid and Controller has been set. Server calls it inside PossessedBy function, client inside OnRep_PlayerState function (a rep notifier i.e. a function being called as a result of something being replicated); for enemies ASC lives on pawn, so call it inside BeginPlay.
	- For Mixed Replication mode, the OwnerActor's Owner must be the Controller. For pawns, this is set automatically in PossessedBy(). The PlayerState's Owner is automatically set to the Controller. So if your OwnerActor is not the PlayerState, and you used Mixed Replication mode, you must call SetOwner() on the OwnerActor to set its owner to the Controller.


4. Attributes
	- FGameplayAttributeData is the type for attributes. Inside OnRep_Health (notifier), we call the macros in charge of notifying the AS (GAMEPLAYATTRIBUTE_REPNOTIFY). To mark a variable as replicated, the function in charge is GetLifetimeReplicatedProps. Inside here, we call DOREPLIFETIME_CONDITION_NOTIFY macro.
	- ATTRIBUTE_ACCESSORS is a container macro for defining several accessor macros, for easily initting, setting and getting the attributes (with Init/Get/Set<AttributeName>).


5. RPG Game UI
	- UI uses MVC design pattern. The View is the widget, the controller is Widget controller and the Model is the data. The controller is in charge of transmitting data to the view, but also of transmitting button presses from the view to the data. It can also have algorithmic logic inside. One way dependency: so the widget's depend on the controller (controller doesnt need to know which widget are receiving data broadcast to them), and the controller depends on the model (controller doesn't need to know the widget that the system has).
	- All the (globe) progress bars (health and mana) are handled via blueprint: the HUD class adds these widget to the viewport, in the InitOverlay function (called in AuraCharacter during InitAbilityActorInfo). 
	- AuraWidgetController is the mother class, OverlayWidgetController is inherited. All widget controllers have a struct containing pointers to PlayerController, PlayerState, AbilitySystemComponent and AttributeSet.
	- To change Health/Mana in the view we use callbacks (delegates). The Broadcast function triggers the delegate, and calls all functions that have been bound to that delegate (through AddLambda). Remember that the MACRO is necessary to define the custom TYPE of your delegate, and then you define it's instances.
	- When we call OnAttributeChanged.Broadcast as a callback for when a GameplayAttribute changes, the trigger for the actual change of the view is made in blueprint (event graph of the WBP).


6. Gameplay Effects
	- Gameplay Effects (GE) change attributes through modifiers. They can be instant, (have a) duration, infinite, or periodic (treated like instant, permanently changing the Base value), and they can stack. Instant applies its modifiers immediately, once, then expires; Infinite applies and persists indefinitely until explicitly removed (by another effect, an ability ending, or a tag condition); Duration applies for a fixed amount of time, then automatically expires. Periodic executes its effect repeatedly at intervals (ticks) during its active time.
    - GESpec (specification) tells us what UGameplayEffect (const data), what level and who instigated. GESpecHandle allows blueprints to generate a GameplayEffectSpec once and then reference it by handle, to apply it multiple times/multiple targets.
    - GEContext is a Data structure that stores an instigator and related data, such as positions and targets. Games can subclass this structure and add game-specific information. It is passed throughout effect execution so it is a great place to track transient information about an execution. GEContextHandle wraps a FGameplayEffectContext or subclass, to allow it to be polymorphic and replicate properly.
    - In GE blueprint in the editor, section Gameplay Effect/Modifiers is where you select what attribute to modify from the AttributeSet of the Target
    - Stacking: Aggregate by Source (how many stacks that source specifically already applied in general): so a difference source could apply other stacks, and the counter would start from 0 again; Aggregate by Target (how many stacks has the target received, independently if they are from difference sources)
	- AuraAffectActor is a class attached to any actor able to apply a (Gameplay) effect to other actors overlapping with it (usually objects, potions, colliders etc.). Policies (coded as ENUMS) decide how the AuraEffectActor will apply or remove the effects, and are set into the editor. They are kept to None/Don't Apply for the type of effects that are not the ones we mean the actor to apply. We call OnOverlap/EndOverlap in blueprint, and trigger the case (in C++) based on the policy, which in turn calls ApplyEffectToTarget with the correct parameters.
	- PreAttributeChange enforces clamping to avoid Health going in negative etc., and is triggered by changes to Attributes (Attribute Accessors, Gameplay Effects etc.), but executed before that attribute actually changes. It does NOT permanently change the modifier, just the value returned from querying the modifier. Later operations recalculate the Current Value from all modifiers, so we might need to clamp again.
	- PostGameplayEffectExecute is an overriden function triggered after a gameplay effect changes an attribute, and it is incredibly useful as its paramater Data contains a lot of useful properties from both Source and Target of the GE. We indeed use this function to gather this information and store into the FEffectPropertiesEnhanced struct. This wrapper struct has different shared pointers (based on Source/Target Properties) to the FEffectProperties struct, which is where we finally store pointers to all the info we ultimately care about. Finally, we clamp again the Health and Mana (to MaxHealth and MaxMana).
	- Curve Tables (CT, found in miscellaneous) is like an excel spreadsheet, where we decide how to scale the floats that regulate the intensity of how much a GE applies, based on the object level. We can then view this grid of level/effect intensity (row/column) in a graph view. We do this for both HealingCurve and ManaCurve.

7. Gameplay Tags
	-  Tags are like names, hierarchical in nature (FNames at the core), divided by dot for parent-child relationship. ASC implements IGameplayTagAssetInterface, with useful functions as GetOwnedGameplayTags,HasMatchingGameplayTag, HasAllMatchingGameplayTags and HasAnyMatchingGameplayTags. Gameplay Tag Manager keeps tracks of how many instances of a tag exist (tag map count).
	- GEffects can contain tags that they grant to the ASC they are been applied to: GEffect has a duration based effect that grants a tag to the ASC affected, and it gets removed when the duration effect expires. Per example, an ASC might have some ability that it wants to apply, but it might have a blocked tag, or an ASC has a list of required tags to activate an ability. Moreover, tags can be anything such as Inputs, Abilities, Attributes, Damage Types, Buffs/Debuffs, Messages, Data etc.
	- Tag Creation = Edit -> Project Settings -> Gameplay Tags. In UE 5.3, Gameplay Effect tags are now in Gameplay Effect -> Components -> [+ icon], then choose the type of tags you need to add to the Gameplay Effect. You can also create them from the file DefaultGameEngine.ini (in Aura -> config folder). You can also create them from Data Tables (DT, in miscellaneous, then select GameplayTagTableRow as Row structure)
	- So obviously you can apply a tag through a GE: in the GE editor, under the tag section, we have different sub-sections, most important are: 
		- GameplayEffectAssetTag -> Tags the GE has and DOES NOT give to the actor
		- GrantedTags -> These tags are applied to the actor I am applied to
          - These are all subdivided into:
            - Combined Tags -> Tags that I inherited and tags that I added minus tags that I removed
            - Added -> Tags that I have in addition to my parent's tags
            - Removed -> Tags that should be removed if my parent had them
	- Tags can stack when the stacking type of the GE is set to NONE, because in such case, applying multiple GEs, they will count as new GE everytime (so new tags everytime). Instead if stacking type is NOT NONE, then applying this effect multiple times means that the effect stack goes up, and we are only gonna apply that tag once.
	-  In case of instant effect, the tag disappears immediately. So we create a delegate function (EffectApplied) that gets bound to OnGameplayEffectAppliedDelegateToSelf at startup time (remember, the declaration of this delegate is made in parent class AbilitySystemComponent.h, where it also declares the parameters that we then use in our EffectApplied function): now when we pick-up an instant effect, we get all the Asset Tags from the Effect we just received and then broadcast it to the OverlayWidgetController class to generate a message on-screen.
	-  On-screen messages are indeed triggered by EffectAssetTags.Broadcast(), who triggers a Lambda function in OverlayWidgetController where we receive the AssetTagContainer, and for each of it, we lookup onto a table in the editor. The row of each table is defined in the FUIWidgetRow struct in OverlayWidgetController.h class, and the table is defined in the editor. Lookup is based on the parent tag Message (so to avoid looking for non-message type of tag), and after we find the row corresponding to our tag, we trigger a delegate (broadcasting the row) defined in blueprint (WBP_Overlay), who in turn creates a widget of type MessageWidget, setting animated image and text (taken from the received row information).

8. RPG Attributes
   - Initialization of attributes can be applied either through DTs or GEs. Through DTs, we create a DT (with row structure = AttributeMetaData), with AuraAttributeSet.X as rows (X being the attribute), and then assign the DT to the exposed ASC in the editor of AuraPlayerState, section AttributeTest -> Default Starting Data. Through GEs, we self-apply GE_AuraPrimaryAttributes in our CharacterBase at startup time (InitializePrimaryAttribute function called in InitAbilityActorInfo). Our preferred way is with GE and that's how we will initialize our attributes.
   - We always used Scalable Floats as modifiers, but now we want to use Attribute Based: they are based on other attributes, so these are effects that can modify an attribute (adding/subtracting etc.) based on the value of other attributes (GE -> Modifiers -> Index -> Modifier Magnitude -> Attribute Based Magnitude -> Backing Attribute. Order of modifiers is important, as it will be the order in which they will be applied..... especially if we use multiply/divide!
   - Thanks to coefficients, for each modifier (index), we can flexibly manipulate the values of each modifier before they get summed/subtracted etc. to other modifiers. Specifically, just above "Backing Attribute" subsection, we can find Pre Multiply Additive Value (which is summed to the attribute BEFORE the coefficient multiplication), the coefficient itself (which is multiplied to the attribute), and Post Multiply Additive Value (which is summed to the attribute AFTER the coefficient multiplication).
   - Derived attributes are attributes that DEPEND on other attributes (i.e. secondary attributes, mainly depending on the primary ones)... so that means that primary attributes may apply effects/increase/decrease secondary attributes. We now therefore have 3 division of attributes: Primary, Secondary and Vital (Health and Mana only). Secondary Attributes get initialized via a self-applied GE at startup time, just like we do for the primary ones.