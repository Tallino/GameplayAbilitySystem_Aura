1. Introduction
	- Introduction to the Course.
2. Project Creation
	- Setup inheritance: AuraCharacterBase is base class, AuraCharacter and AuraEnemy are inherited.
	- 2 different type of enemy (with different animations): Goblin slingshots and Goblin Spearmen.
	- Animations take Velocity from CharacterMovement component and sets it to the Animation (in blueprint).
	- Enhanced Input (IMC file) used in AuraPlayerController. It is stored in IMC file (Input Mapping Context). D keybind is negated A, same for Y axis (Swizzle) etc.
	- Move function is bound to Enhanced Input Component at startup time (SetupInputComponent). Binding to MoveAction (of type UInputAction), then used in the editor with the same name.
	- EnemyInterface abstract class is given to all enemies to inherit from. From the Player Controller, at each tick, we call CursorTrace(), checking the HitResult under the cursor trace. If the actor hit is inheriting the interface (checked with a cast), then we highlight the actor (or unhighlight) with a LastActor/ThisActor logic.
3. Intro to the Gameplay Ability System
	- Enemies have the Ability System Component and AttributeSet directly on the character class, but for the player it is kept on the PlayerState (so it is not lost when the player dies).
	- Each client has its own game state/copy, same for the server, but server's copy is the authorative one. Replication of attribute changes happens only from server to client. If client want to replicate to server, he must use RPCs.
	- Replication Mode on player will be of type Mixed (GEs will be replicated to owning client only), while on enemies will be of type Minimal (GEs won't be replicated).
	- ASCs have Owner Actor and Avatar Actor. So for enemies, Owner and Avatar are the same Enemy Character. For players, the Owner Actor is the Player State, while the Avatar Actor will be the character.
	- InitAbilityActorInfo must be done after possession: for players ASC lives on PlayerState, so make sure that PlayerState is valid and Controller has been set. Server calls it inside PossessedBy function, client inside OnRep_PlayerState function (a rep notifier i.e. a function being called as a result of something being replicated); for enemies ASC lives on pawn, so call it inside BeginPlay.
	- For Mixed Replication mode, the OwnerActor's Owner must be the Controller. For pawns, this is set automatically in PossessedBy(). The PlayerState's Owner is automatically set to the Controller. So if your OwnerActor is not the PlayerState, and you used Mixed Replication mode, you must call SetOwner() on the OwnerActor to set its owner to the Controller.
4. Attributes
	- FGameplayAttributeData is the type for attributes. Inside OnRep_Health (notifier), we call the macros in charge of notifying the AS (GAMEPLAYATTRIBUTE_REPNOTIFY). To mark a variable as replicated, the function in charge is GetLifetimeReplicatedProps. Inside here, we call DOREPLIFETIME_CONDITION_NOTIFY macro.
	- ATTRIBUTE_ACCESSORS is a container macro for defining several accessor macros, for easily initting, setting and getting the attributes (with Init/Get/Set<AttributeName>).
5. RPG Game UI
	- UI uses MVC design pattern. The View is the widget, the controller is Widget controller and the Model is the data. The controller is in charge of transmitting data to the view, but also of transmitting button presses from the view to the data. It can also have algorithmic logic inside. One way dependency: so the widget's depend on the controller (controller doesn't need to know which widget are receiving data broadcast to them), and the controller depends on the model (controller doesn't need to know the widget that the system has).
	- All the (globe) progress bars (health and mana) are handled via blueprint: the HUD class adds these widget to the viewport, in the InitOverlay function (called in AuraCharacter during InitAbilityActorInfo). 
	- AuraWidgetController is the mother class, OverlayWidgetController is inherited. All widget controllers have a struct containing pointers to PlayerController, PlayerState, AbilitySystemComponent and AttributeSet.
	- To change Health/Mana in the view we use callbacks (delegates). The Broadcast function triggers the delegate, and calls all functions that have been bound to that delegate (through AddLambda). Remember that the MACRO is necessary to define the custom TYPE of your delegate, and then you define its instances.
	- When we call OnAttributeChanged.Broadcast as a callback for when a GameplayAttribute changes, the trigger for the actual change of the view is made in blueprint (event graph of the WBP).
6. Gameplay Effects
	- Gameplay Effects (GE) change attributes through modifiers. They can be instant, (have a) duration, infinite, or periodic (treated like instant, permanently changing the Base value), and they can stack. Instant applies its modifiers immediately, once, then expires; Infinite applies and persists indefinitely until explicitly removed (by another effect, an ability ending, or a tag condition); Duration applies for a fixed amount of time, then automatically expires. Periodic executes its effect repeatedly at intervals (ticks) during its active time.
    - GESpec (specification) tells us what UGameplayEffect (const data), what level and who instigated. GESpecHandle allows blueprints to generate a GameplayEffectSpec once and then reference it by handle, to apply it multiple times/multiple targets.
    - GEContext is a Data structure that stores an instigator and related data, such as positions and targets. Games can subclass this structure and add game-specific information. It is passed throughout effect execution, so it is a great place to track transient information about an execution. GEContextHandle wraps a FGameplayEffectContext or subclass, to allow it to be polymorphic and replicate properly.
    - In GE blueprint in the editor, section Gameplay Effect/Modifiers is where you select what attribute to modify from the AttributeSet of the Target
    - Stacking: Aggregate by Source (how many stacks that source specifically already applied in general): so a difference source could apply other stacks, and the counter would start from 0 again; Aggregate by Target (how many stacks has the target received, independently if they are from difference sources)
	- AuraAffectActor is a class attached to any actor able to apply a (Gameplay) effect to other actors overlapping with it (usually objects, potions, colliders etc.). Policies (coded as ENUMS) decide how the AuraEffectActor will apply or remove the effects, and are set into the editor. They are kept to None/Don't Apply for the type of effects that are not the ones we mean the actor to apply. We call OnOverlap/EndOverlap in blueprint, and trigger the case (in C++) based on the policy, which in turn calls ApplyEffectToTarget with the correct parameters.
	- PreAttributeChange enforces clamping to avoid Health going in negative etc., and is triggered by changes to Attributes (Attribute Accessors, Gameplay Effects etc.), but executed before that attribute actually changes. It does NOT permanently change the modifier, just the value returned from querying the modifier. Later operations recalculate the Current Value from all modifiers, so we might need to clamp again.
	- PostGameplayEffectExecute is an overriden function triggered after a gameplay effect changes an attribute, and it is incredibly useful as its paramater Data contains a lot of useful properties from both Source and Target of the GE. We indeed use this function to gather this information and store into the FEffectPropertiesEnhanced struct. This wrapper struct has different shared pointers (based on Source/Target Properties) to the FEffectProperties struct, which is where we finally store pointers to all the info we ultimately care about. Finally, we clamp again the Health and Mana (to MaxHealth and MaxMana). 
	- Curve Tables (CT, found in miscellaneous) is like an Excel spreadsheet, where we decide how to scale the floats that regulate the intensity of how much a GE applies, based on the object level. We can then view this grid of level/effect intensity (row/column) in a graph view. We do this for both HealingCurve and ManaCurve.
7. Gameplay Tags
	-  Tags are like names, hierarchical in nature (FNames at the core), divided by dot for parent-child relationship. ASC implements IGameplayTagAssetInterface, with useful functions as GetOwnedGameplayTags,HasMatchingGameplayTag, HasAllMatchingGameplayTags and HasAnyMatchingGameplayTags. Gameplay Tag Manager keeps tracks of how many instances of a tag exist (tag map count).
	- GEffects can contain tags that they grant to the ASC they are been applied to: GEffect has a duration based effect that grants a tag to the ASC affected, and it gets removed when the duration effect expires. Per example, an ASC might have some ability that it wants to apply, but it might have a blocked tag, or an ASC has a list of required tags to activate an ability. Moreover, tags can be anything such as Inputs, Abilities, Attributes, Damage Types, Buffs/Debuffs, Messages, Data etc.
	- Tag Creation = Edit -> Project Settings -> Gameplay Tags. In UE 5.3, Gameplay Effect tags are now in Gameplay Effect -> Components -> [+ icon], then choose the type of tags you need to add to the Gameplay Effect. You can also create them from the file DefaultGameEngine.ini (in Aura -> config folder). You can also create them from Data Tables (DT, in miscellaneous, then select GameplayTagTableRow as Row structure)
	- So obviously you can apply a tag through a GE: in the GE editor, under the tag section, we have different subsections, most important are: 
		- GameplayEffectAssetTag -> Tags the GE has and DOES NOT give to the actor
		- GrantedTags -> These tags are applied to the actor I am applied to
          - These are all subdivided into:
            - Combined Tags -> Tags that I inherited and tags that I added minus tags that I removed
            - Added -> Tags that I have in addition to my parent's tags
            - Removed -> Tags that should be removed if my parent had them
	-  Tags can stack when the stacking type of the GE is set to NONE, because in such case, applying multiple GEs, they will count as new GE everytime (so new tags everytime). Instead, if stacking type is NOT NONE, then applying this effect multiple times means that the effect stack goes up, and we are only going to apply that tag once.
	-  In case of instant effect, the tag disappears immediately. So we create a delegate function (EffectApplied) that gets bound to OnGameplayEffectAppliedDelegateToSelf at startup time (remember, the declaration of this delegate is made in parent class AbilitySystemComponent.h, where it also declares the parameters that we then use in our EffectApplied function): now when we pick up an instant effect, we get all the Asset Tags from the Effect we just received and then broadcast it to the OverlayWidgetController class to generate a message on-screen.
	-  On-screen messages are indeed triggered by EffectAssetTags.Broadcast(), who triggers a Lambda function in OverlayWidgetController where we receive the AssetTagContainer, and for each of it, we look up onto a table in the editor. The row of each table is defined in the FUIWidgetRow struct in OverlayWidgetController.h class, and the table is defined in the editor. Lookup is based on the parent tag Message (so to avoid looking for non-message type of tag), and after we find the row corresponding to our tag, we trigger a delegate (broadcasting the row) defined in blueprint (WBP_Overlay), who in turn creates a widget of type MessageWidget, setting animated image and text (taken from the received row information).
8. RPG Attributes
   - Initialization of attributes can be applied either through DTs or GEs. Through DTs, we create a DT (with row structure = AttributeMetaData), with AuraAttributeSet.X as rows (X being the attribute), and then assign the DT to the exposed ASC in the editor of AuraPlayerState, section AttributeTest -> Default Starting Data. Through GEs, we self-apply GE_AuraPrimaryAttributes in our CharacterBase at startup time (InitializePrimaryAttribute function called in InitAbilityActorInfo). Our preferred way is with GE and that's how we will initialize our attributes.
   - We always used Scalable Floats as modifiers, but now we want to use Attribute Based: they are based on other attributes, so these are effects that can modify an attribute (adding/subtracting etc.) based on the value of other attributes (GE -> Modifiers -> Index -> Modifier Magnitude -> Attribute Based Magnitude -> Backing Attribute). Order of modifiers is important, as it will be the order in which they will be applied..... especially if we use multiply/divide!
   - Thanks to coefficients, for each modifier (index), we can flexibly manipulate the values of each modifier before they get summed/subtracted etc. to other modifiers. Specifically, just above "Backing Attribute" subsection, we can find Pre Multiply Additive Value (which is summed to the attribute BEFORE the coefficient multiplication), the coefficient itself (which is multiplied to the attribute), and Post Multiply Additive Value (which is summed to the attribute AFTER the coefficient multiplication).
   - Derived attributes are attributes that DEPEND on other attributes (i.e. secondary attributes, mainly depending on the primary ones)... so that means that primary attributes may apply effects/increase/decrease secondary attributes. We now therefore have 3 division of attributes: Primary, Secondary and Vital (Health and Mana). Secondary Attributes get initialized via a self-applied GE at startup time, just like we do for the primary ones. Same for Vital Attributes, which are initialized last as they depend on MaxHealth and MaxMana (secondary attributes)
   - Modifier Magnitude Calculation (MMC) is a class we create when we want to base our attributes not only on other attributes, but on other entities (in our case, such as the Level, in the PlayerState). We want our MMC (custom calculation) be non-dependant on classes, instead dependent on interfaces (ICombatInterface). All actors who combat can inherit from this interface, where anyone can GetPlayerLevel from it. So Level is on PlayerState for the character, and on the Enemy class for the Enemy. They both inherit from the ICombatInterface, and return their one implementation of GetPlayerLevel.
   - So our MMC classes, inheriting from GameplayModMagnitudeCalculation, are created for both MaxHealth and MaxMana. In the constructor we capture the DEFINITION of the attribute on what they are based on (e.g. Vigor for MaxHealth, Intelligence for MaxMana). Inherited function called CalculateBaseMagnitude_Implementation() is automatically called, and we fill it in with all the information to get the attribute's value and use it as a modifier (together with the Level) for MaxHealth/Mana, and the result finally returned. Remember to set in the editor the attribute's "Magnitude Calculation Type" to "Custom Class Calculation" (in the GE), and finally set the Calculation Class to the MMC classes.
9. Attribute Menu
   - We now design our Attribute Menu. We will have WBP_FramedValue, WBP_TextValueRow, and WBP_TextValueButtonRow (where we can add attribute points to our PRIMARY attributes), all contained in WBP_AttributeMenu, and all of them are controlled (brush, width and height settings) with blueprints in their graph whenever we wanted certain parameters to be variables (and non hardcoded). 
   - WBP_Button is a standalone blueprint used for our open/close buttons and our primary attribute "+" sign, and WBP_WideButton is used in the UI interface to open the AttributesMenu. Finally, we open and close the menu from WBP_Overlay; we also use an Event Dispatcher (i.e, blueprint version of delegates), to which the Overlay subscribes, to know when the menu has been destroyed (X button clicked), so to re-enable the WBP_WideButton.
   - So we need to show attribute changes in the UI, but we want to avoid to create a delegate/broadcast FOR EACH attribute, because it is not scalable. So whenever any attribute changes in the model, a generic delegate will be triggered on the WidgetController (FOnAttributeChanged), who will then broadcast different info thanks to a struct we will create that will be based on the attribute's gameplay tag.
   - So the flow is: Widget controller is bound to delegates from the ASC, so when an attribute changes, the widget controller will know about it. In turn, he will take that attribute and try to figure out what gameplay tag it corresponds. Then we can perform a lookup based on the gameplay tag to find its corresponding struct, finally taking all the information from the struct and sending it to the widget: the entity in charge of taking the tag and returning the corresponding struct is called a Data Asset.
   - AuraGameplayTags is a singleton struct where we initialize the attributes tags natively in C++: we will then get the tags from here when we need to send them to the DataAsset. AssetManager is an in-built singleton class from where we inherit and then assign in DefaultEngine.ini file: we then use the new class (AuraAssetManager) to call the initialization on the AuraGameplayTags class. So we create our AttributeInfo class (derived from DataAsset) where we put our struct + an array member variable containing them. Finally, in the editor (in Miscellaneous) we can create a Data Asset file (based on our custom class), where we can manually input the struct information for each index of the array (i.e., each combo of Attribute Tag + Name + Description).
   - We then create our AttributeMenuWidget controller class. Now that we have another widget controller (in addition to the Overlay widget controller), we still construct in AuraHUD just like the overlay, but we want to easily get the widget controller without going through all the classes: in other words, widgets shouldn't go through the GetController function of the HUD to get their controller. So we will use a Blueprint Function Library, where we can use blueprint callable static functions to easily access the controller we want.
   - Therefore, AuraAbilitySystemLibrary class is created where we statically get the widget controllers, through pure blueprint functions, that ultimately gets the controller from the HUD. The HUD constructs the AttributeMenu (in C++), then gets the AttributeMenuWidgetController from the Blueprint Library (who gets it from the HUD, for the reasons said above), and then finally set its controller (all in the blueprint graph).
   - In AttributeMenuWidgetController we create a delegate (in C++) to which the Attribute Rows widget will subscribe. So we find our AttributeInfo struct through tag, broadcast the struct to the widget, who (in blueprint) will set text and value (taken from the broadcast struct). The functions are declared in the base class (WBP_TextValueRow), and called in child class WBP_TextValueButtonRow right after the triggered delegate.
   - To assign the correct name of each attribute to the attribute menu in the UI, we give a name to all rows, make them variables, and set their Attribute Tag in the graph of WBP_AttributeMenu (SetAttributeTags function). Then, in the graph of TextValueRow and TextValueButtonRow, we match the AttributeTag received from the broadcast struct of the controller with the AttributeTag of that specific row: if they match, we set the label.
   - So in the AttributeSet we create a map TagToAttribute, that maps GameplayTags (Attribute Tags) to function pointers (which store the return value of the static getters (accessors) of our attributes). Since the return type of the function pointer is of type TBaseStaticDelegateInstance and a lot of other horrible stuff, we decide to use aliasing to call it simply TStaticFuncPtr (templated version to store whatever func pointer we want). So in the constructor of AuraAttributeSet we add the pairs (AttributeTag to its static getter) to the map, then in the widget controller we loop in the map, based on the AttributeTag key we get the Attribute variable, from which we GetNumericalValue, finally adding the value to the AttributeInfo struct and then broadcasting it to the widget.
   - Finally, to be sure that attributes change in the UI when they change at runtime, we loop (in BindCallbacksToDependencies) into our map binding to each Attribute a lambda function (thanks to in-built function GetGameplayAttributeValueChangeDelegate, so trigger the lambda everytime the attribute changes). The lambda is obviously the usual broadcast of the correct AttributeInfo struct to the widgets.
10. Gameplay Abilities
    - Gameplay abilities are actions/skills that an actor can perform, but rather than implementing the action with a simple function, a GA can be an instanced object, running asynchronously. This means it can be activated at some point in time, and run multistage tasks, that may or may not span across periods of time. Ability Tasks perform asynchronous work during a gameplay ability execution. They can affect execution flow by broadcasting delegates.
    - The ASC must be granted the ability, and when this happens, a GameplayAbilitySpec is created (it defines the detail pertaining the GA). Abilities are granted on server, and when this happens, the Spec is replicated to the client, so they can activate it from there. Once activated, GAs are said to be active. Then they either End, or Cancelled. Finally, they have cost and cooldown, and they can run asynchronously (multiple active at the same time).
    - In AuraCharacter's PossessedBy we call a function to set the abilities. This calls a function in AuraCharacterBase where we call the ASC passing an array of abilities we set through BP. The ASC will then loop in this array and finally add + activate the abilities. Our base class for all GAs is AuraGameplayAbility.
    - Abilities Tags are the tags that the abilities has. All the rest of the settings are explained in the comments in the details panel of the GA. What NOT TO USE: Replication Policy (Useless, as GAs are already replicated automatically); Server Respects Remote Ability Cancellation (it means the client can decide on the server, not a good idea); Replicate Input Directly (so possibly calling an RPC at each frame, highly non-performative and therefore discouraged).
    - So we want to bind inputs to GAs. Before we bound inputs directly to the ASC, but it was too rigid. Now with Enhanced input, we bind them via the Input Mapping Context. We will have a data driven approach, using a Data Asset that is going to contain input actions, each linked with gameplay tags. So we want to assign various tags to our GAs, in order change input-to-ability mappings at runtime.
    - AuraInputConfig is our Data Asset based class where we store arrays of structs composed of gameplay tags and input actions. Input actions are created in blueprint and assigned to the first 4 numbered keys + left mouse click + right mouse click in our IMC_AuraContext file. Tags are created natively in C++ in our GameplayTags singleton file. Finally, they are paired via blueprint in the array mentioned before.
    - AuraInputComponent instead is where we declare a template function in charge of binding the future gameplay functions to the InputActions, passing a tag as an input parameter. Each Input Action will be able to bind up to 3 different function: for Pressed, Released and Held. In AuraPlayerController we call the BindActions, passing in the InputConfig, and bind to each of our actions (as for now, 4 keys + LMB + RMB) three different functions for pressed, held and released. We can indeed also see printed out the tags associated to the actions.
    - Finally, from the PlayerController we call the functions in the ASC that then activates the abilities with exact tag match. Remember that when (in function AddCharacterAbilities) we loop through the StartupAbilities array (set in BP on AuraCharacter), adding their tag to the DynamicAbilityTags array, then finally give the ability to the ASC, we can then find the abilities in a prebuilt array called GetActivatableAbilities(). Indeed, this is where we finally take the Specs and activate them based on their tag (calling, in the ASC, the final prebuilt function AbilitySpecInputPressed);
    - To move our character we will use AddMovementInput (as it works also in multiplayer). But since normal pathfinding algorithms would result in abrupted change of movements in case of an obstacle lying in the middle of the path, we will use a spline to approximate the path with a curve and make it smoother. First of all, when we click the first time (inside AbilityInputTagPressed), we check if we are using the LMB and if we are targeting something, setting a boolean). Then, inside AbilityInputTagHeld, if we are not using LMB it means we are using an ability for sure, else, if we are using LMB and not targeting, then again, we are using an ability for sure. Finally, if we are using LMB and NOT targeting, then we cache the direction under the cursor, and add movement input to that direction.
    - In AbilityInputTagReleased instead, we do the same check as before, but if we are using LMB and NOT targeting, when we release, we want to autorun there: we use FindPathToLocationSynchronously(), taking the pathPoints of the result and adding them to our spline component. In the tick, we check if we are autorunning, and if yes, we add movement in the direction of the closes spline point to us. If we get close to the point under the AutoRunAcceptanceRadius, we stop.
    - We now want to create projectiles and our base class will be AuraProjectile. All children of this class will have a USphereComponent and a UProjectileMovementComponent (we set initial speeds already). In BeginPlay, we AddDynamic (delegate) to function OnSphereOverlap. AuraProjectileSpell instead is our GA class (inheriting from GameplayAbility.h), that will override and call ActivateAbility